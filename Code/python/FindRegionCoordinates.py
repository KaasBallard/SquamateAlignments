#!/home/administrator/mambaforge/envs/biopython/bin/python

# region Import Modules
# Import required modules
import os
import sys
import re
import argparse
from Bio import SeqIO
import polars as pl
# endregion


# region Helper Function Definitions

# Function #1: fasta_to_dataframe
def fasta_to_dataframe(fasta):
	"""
	Converts a FASTA file to a polars DataFrame object. 

	Args:
		fasta (str): Path to the FASTA file.

	Returns:
		pl.DataFrame: A DataFrame with 'header' and 'sequence' columns.
	"""

	# Parse the FASTA and extract headers and sequences
	records = SeqIO.parse(fasta, 'fasta')
	# Initialize empty lists to store headers and sequences
	headers = []
	sequences = []

	# Iterate over the records and append the headers and sequnences to the respective lists
	for record in records:
		headers.append(str(record.id))
		sequences.append(str(record.seq))
	
	# Create a polars data frame from the headers and sequences
	df = pl.DataFrame({'headers': headers, 'sequences': sequences})

	return df

# Function #2: find_subsequence_range
def find_subsequence_range(sequence, pattern = "N+"):
	"""
	Find the start and end positions of a subsequence within a larger sequence.

	Args:
		sequence (str): The sequence to search within.
		pattern (str): The subsequence regular expression pattern to search for (Default: "N+").
	Returns:
		List of tuples: List of start and end positions of the subsequence 
		where N's are found. Each tuple is in the form (start, end), where 
		start is zero indexed for a BED file.
	"""

	# Initialize an empty variable to store the current sequence coordinates
	coordinates = []

	# Find all the matches for the pattern in the sequence
	for match in re.finditer(pattern, sequence):
		start, end = match.span()
		# Adjust the end position to be inclusive like in a BED file format
		coordinates.append((start, end - 1))

	# Return the coordinates
	return coordinates


# Function #3: form_dataframe
def form_dataframe(df, pattern = "N+"):
	"""
	Forms a polars DataFrame object from a FASTA file and performs necessary operation to get into BED format.

	Args:
		df (pl.DataFrame): A DataFrame with 'header' and 'sequence' columns created by the fasta_to_dataframe function.
		pattern (str): The subsequence regular expression pattern to search for, which is passed to the find_subsequence_range function (Default: "N+").
	
	Returns:
		pl.DataFrame: A DataFrame with 'header', 'start', and 'end' columns in BED format, with 'start' and 'end'
		being generated by the find_subsequence_range function.
	"""

	# Take the input DataFrame and perform the necessary operations to get it into BED format
	df = (
		df
		.with_columns(
			pl.col('sequences').map_elements(
				lambda x: find_subsequence_range(x, pattern),
				return_dtype = pl.List(pl.List(pl.Int64))
			)
			.alias('coordinates')
		)
		# Drop the sequences column, as it is no longer needed
		.drop(['sequences'])
		# Explode the coordinates column to create a new row for each coordinate
		.explode('coordinates')
		# Create two new columns for the start and end cooordinates
		.with_columns(
			pl.col('coordinates').list.get(0).alias('start'),
			pl.col('coordinates').list.get(1).alias('end')
		)
		# Drop the coordinates column, as it is no longer needed
		.drop(['coordinates'])
		# Drop any rows with null values
		.drop_nulls()
		# Make sure all values are unique
		.unique(maintain_order=True)
	)

	# Return the DataFrame
	return df

# Function #4: parse_arguments
def parse_arguments():
	"""
	Parse the command line arguments.
	
	Returns:
		argparse.Namespace: The parsed arguments for the command line.
	"""
	parser = argparse.ArgumentParser(
		description = 'Find regions in a FASTA file based on a regex pattern and output to BED format.'
	)

	# Add the arguments
	parser.add_argument('-f', '--fasta', required = True, help = 'Path to the input FASTA file')
	parser.add_argument('-r', '--regex', default = "N+", help = 'Regular expression pattern to search for (default: "N+")')
	parser.add_argument('-b', '--bed', required = True, help = 'Path to the output BED file')

	# Return the parsed arguments
	return parser.parse_args()

# endregion


# region Main

# Define the main function
def main():
	# Parse the command line arguments
	args = parse_arguments()

	# Set the path for the input FASTA file
	fasta = args.fasta

	# Check if the file exists
	if os.path.exists(fasta):
		print(f'File {fasta} exists. Proccessing...')
	else:
		print(f'File {fasta} does not exist. Exiting...')
		sys.exit(1)

	# Convert the FASTA file to a DataFrame
	df = fasta_to_dataframe(fasta)

	# Form the DataFrame into a BED formated DataFrame
	df = form_dataframe(df)

	# Set the BED file path
	bed = args.bed

	# Save the DataFrame to a BED file
	df.write_csv(
		file = bed,
		include_header = False,
		separator = '\t'
	)

	# Check that the BED file was created
	if os.path.exists(bed):
		print(f'File {bed} created successfully.')
	else:
		print(f'Error: File {bed} was not created.')

# Runt the main function if the script is executed directly
if __name__ == "__main__":
	main()
# endregion